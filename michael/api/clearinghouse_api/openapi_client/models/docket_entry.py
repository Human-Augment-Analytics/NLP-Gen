# coding: utf-8

"""
    Civil Rights Clearinghouse Simple API

    Python Client to Scrapte the University of Michigan Civil Rights Clearinghouse.  Basic installation: ```sh pip install git+https://github.com/calexander/law-data-design-vip.git ``` 

    The version of the OpenAPI document: 0.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.docket_entry_attachments_inner import DocketEntryAttachmentsInner
from typing import Optional, Set
from typing_extensions import Self

class DocketEntry(BaseModel):
    """
    A docket lists, in chronological order, every document filed with the court in a case. Each document and its accompanying information is a \"docket entry.\" For more information about dockets, see [Docket](https://api.clearinghouse.net/api-reference/objects/docket). Dockets can be saved one of two ways in the Clearinghouse: (1) as parsed docket entries, or (2) as a PDF. This docket entry object is for parsed docket entries. For PDF dockets, the docket is saved as a document (see [Documents](https://api.clearinghouse.net/api-reference/objects/case/documents)). For federal docket entries from RECAP, some entries might be taken from PACER's RSS feed. These \"RSS\" entries have incomplete information. 
    """ # noqa: E501
    row_number: Optional[StrictInt] = Field(default=None, description="The position of the docket entry within the docket, where the docket is a zero-indexed array of entries.")
    entry_number: Optional[StrictStr] = Field(default=None, description="For dockets that are numbered by the court, the number assigned to the docket entry. Unlike row_number, these numbers start with 1. In federal court, this is known as an \"ECF number,\" and every federal docket entry should have an ECF number. If the docket entry is part of a federal docket but entry_number is null, then the docket entry is likely an \"RSS entry\" (see above). For state courts, states vary as to whether they assign numbers to docket entries, so whether entry_number is null depends on the state. ")
    date_filled: Optional[StrictStr] = Field(default=None, description="The date of the docket entry, i.e. when the document was filed. This is in the format \"YYYY-MM-DDTHH:MM:ssTZ\".")
    description: Optional[StrictStr] = Field(default=None, description="The text that describes the document in a docket entry. For RSS entries in federal dockets (see above), this will be an abbreviated version of the actual docket entry description (often just the type of document).")
    attachments: Optional[List[DocketEntryAttachmentsInner]] = Field(default=None, description="Sometimes documents are attached to another document in PACER/RECAP. If so, the attached documents (\"attachments\") are gathered in an array associated with a docket entry. Attachments have the following fields: ***recap_ip*** - The ID number given by RECAP. ***pacer_url*** - The URL to the document in PACER. ***description*** - A short description of the document. Unlike a docket entry's overall description, an attachment description tends to be very short. ***attachment_number*** - Starting from 1, position of the attachment among the attachments for the docket entry. ")
    url: Optional[StrictStr] = Field(default=None, description="A URL to a page that embeds the document. For federal cases, this is a link to a [CourtListener (RECAP)](https://www.courtlistener.com/) page. For state cases, this is a link to a [Docket Alarm](https://www.docketalarm.com/) page. For RSS entries in federal dockets (see above), this link is simply \"https://www.courtlistener.com\".")
    recap_pdf_url: Optional[StrictStr] = Field(default=None, description="A URL to the document (i.e. the PDF itself). If there is no such URL available or if this an RSS entry in a federal docket (see above), this field is null.")
    pacer_doc_id: Optional[StrictStr] = Field(default=None, description="The ID of the document in PACER. PACER, which stands for Public Access to Court Electronic Records, is the federal government's electronic system for providing access to federal court records. For RSS entries in federal dockets (see above), this field is null. ")
    id: Optional[StrictInt] = Field(default=None, description="The ID of the docket entry in the Clearinghouse.")
    __properties: ClassVar[List[str]] = ["row_number", "entry_number", "date_filled", "description", "attachments", "url", "recap_pdf_url", "pacer_doc_id", "id"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DocketEntry from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in attachments (list)
        _items = []
        if self.attachments:
            for _item_attachments in self.attachments:
                if _item_attachments:
                    _items.append(_item_attachments.to_dict())
            _dict['attachments'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DocketEntry from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "row_number": obj.get("row_number"),
            "entry_number": obj.get("entry_number"),
            "date_filled": obj.get("date_filled"),
            "description": obj.get("description"),
            "attachments": [DocketEntryAttachmentsInner.from_dict(_item) for _item in obj["attachments"]] if obj.get("attachments") is not None else None,
            "url": obj.get("url"),
            "recap_pdf_url": obj.get("recap_pdf_url"),
            "pacer_doc_id": obj.get("pacer_doc_id"),
            "id": obj.get("id")
        })
        return _obj


